🧠 Partie 1 : Questions ouvertes / explications (réponds franchement sans regarder de code)
Q1.
À quoi doit servir la variable len dans la fonction récursive ?
→ cest la longueur du subset, sousensemble de termes. ca sert comme curseur, index. subset[len] et ensuite len + 1,

Q2.
Pourquoi doit-on utiliser subset[len] et non subset[pos] pour ajouter un nouvel élément au sous-ensemble courant ?
→ pos est l'index pour le set, soit lensemble de nombre a disposition pour former le subset. pos est donc un index qui parcours la chaine du set et non pas du subset. set[pos] et subset[len] ca cest correct.

Q3.
Dans l’appel récursif, quel paramètre doit-on incrémenter pour explorer l’élément suivant dans l’ensemble initial (set[]) ?
→ set[pos + 1]. car set est lensemble initial et pos son index attitre. donc le parametre a incrementer est pos. 

Q4.
Explique en une phrase ce que signifie “backtracking naturel” quand on utilise un tableau subset[] dans une récursivité bien faite.
→ le backtracking naturel est un cas de figure ou le rollback est fait dans la recursive elle-meme donc pas besoin de la formuler a la suite de la ligne de recursive.

Q5.
À quel moment (dans quelle condition) doit-on afficher le sous-ensemble trouvé ?
→ si la somme est egale a la cible :) ca cest facile. 

Q6.
Pourquoi ne doit-on pas modifier la taille de l’ensemble d’origine (nb_set) dans les appels récursifs ?
→

Q7.
Si on veut éviter d’avoir des sous-ensembles contenant des 0 non désirés, comment doit-on parcourir ou afficher le tableau subset[] ?
→

✔️ Partie 2 : QCM ciblés (une ou plusieurs bonnes réponses, parfois “aucune des réponses”)
QCM 1
La signature correcte pour une fonction powerset qui génère tous les sous-ensembles ayant une somme donnée est :

a) void powerset(int *set, int nb_set, int pos, int *subset, int len, int sum, int target);
b) void powerset(int *set, int nb_set, int i, int *subset, int sum, int target);
c) void powerset(int *set, int nb_set, int pos, int *subset, int len, int sum, int target, int i);
d) Aucune des réponses

QCM 2
Quelle(s) variable(s) faut-il incrémenter dans l’appel récursif pour avancer la recherche sur set[] ?
a) pos
b) len
c) sum
d) nb_set

QCM 3
Dans le backtracking du subset sum, que doit-on faire juste après l’appel récursif pour “retirer” le dernier élément ajouté dans subset[] ?

a) Mettre subset[len] = 0;
b) Rien, car la récursivité va réécrire ou écraser cet index au prochain essai
c) Libérer l’emplacement mémoire
d) Appeler une fonction spéciale de nettoyage

QCM 4
Que se passe-t-il si tu affiches tous les éléments de subset[] jusqu’à sa taille maximale sans prendre en compte la longueur courante (len) ?

a) Tu obtiens toujours les sous-ensembles corrects
b) Tu risques d’afficher des 0 ou des valeurs parasites
c) Tu peux avoir des répétitions d’éléments
d) Ton programme peut crasher

QCM 5
Dans le code suivant, que fait exactement la variable pos ?

c
Copier
Modifier
for (int pos = start; pos < nb_set; pos++) {
    subset[len] = set[pos];
    powerset(set, nb_set, pos + 1, subset, len + 1, sum + set[pos], target);
}
a) Elle sert à parcourir tous les choix possibles à partir d’une position donnée
b) Elle indique la profondeur de la récursion
c) Elle sert à contrôler la taille de l’ensemble initial
d) Elle n’est pas utile

QCM 6
Quand faut-il arrêter la branche récursive (en-dehors du cas de base) ?

a) Quand la somme courante dépasse la cible
b) Quand on atteint la fin du tableau
c) Quand subset[] est plein
d) Jamais, il faut explorer toutes les possibilités
