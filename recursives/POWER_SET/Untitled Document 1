ğŸ§  Partie 1 : Questions ouvertes / explications (rÃ©ponds franchement sans regarder de code)
Q1.
Ã€ quoi doit servir la variable len dans la fonction rÃ©cursiveâ€¯?
â†’ cest la longueur du subset, sousensemble de termes. ca sert comme curseur, index. subset[len] et ensuite len + 1,

Q2.
Pourquoi doit-on utiliser subset[len] et non subset[pos] pour ajouter un nouvel Ã©lÃ©ment au sous-ensemble courantâ€¯?
â†’ pos est l'index pour le set, soit lensemble de nombre a disposition pour former le subset. pos est donc un index qui parcours la chaine du set et non pas du subset. set[pos] et subset[len] ca cest correct.

Q3.
Dans lâ€™appel rÃ©cursif, quel paramÃ¨tre doit-on incrÃ©menter pour explorer lâ€™Ã©lÃ©ment suivant dans lâ€™ensemble initial (set[])â€¯?
â†’ set[pos + 1]. car set est lensemble initial et pos son index attitre. donc le parametre a incrementer est pos. 

Q4.
Explique en une phrase ce que signifie â€œbacktracking naturelâ€ quand on utilise un tableau subset[] dans une rÃ©cursivitÃ© bien faite.
â†’ le backtracking naturel est un cas de figure ou le rollback est fait dans la recursive elle-meme donc pas besoin de la formuler a la suite de la ligne de recursive.

Q5.
Ã€ quel moment (dans quelle condition) doit-on afficher le sous-ensemble trouvÃ©â€¯?
â†’ si la somme est egale a la cible :) ca cest facile. 

Q6.
Pourquoi ne doit-on pas modifier la taille de lâ€™ensemble dâ€™origine (nb_set) dans les appels rÃ©cursifsâ€¯?
â†’

Q7.
Si on veut Ã©viter dâ€™avoir des sous-ensembles contenant des 0 non dÃ©sirÃ©s, comment doit-on parcourir ou afficher le tableau subset[]â€¯?
â†’

âœ”ï¸ Partie 2 : QCM ciblÃ©s (une ou plusieurs bonnes rÃ©ponses, parfois â€œaucune des rÃ©ponsesâ€)
QCM 1
La signature correcte pour une fonction powerset qui gÃ©nÃ¨re tous les sous-ensembles ayant une somme donnÃ©e estâ€¯:

a) void powerset(int *set, int nb_set, int pos, int *subset, int len, int sum, int target);
b) void powerset(int *set, int nb_set, int i, int *subset, int sum, int target);
c) void powerset(int *set, int nb_set, int pos, int *subset, int len, int sum, int target, int i);
d) Aucune des rÃ©ponses

QCM 2
Quelle(s) variable(s) faut-il incrÃ©menter dans lâ€™appel rÃ©cursif pour avancer la recherche sur set[]â€¯?
a) pos
b) len
c) sum
d) nb_set

QCM 3
Dans le backtracking du subset sum, que doit-on faire juste aprÃ¨s lâ€™appel rÃ©cursif pour â€œretirerâ€ le dernier Ã©lÃ©ment ajoutÃ© dans subset[]â€¯?

a) Mettre subset[len] = 0;
b) Rien, car la rÃ©cursivitÃ© va rÃ©Ã©crire ou Ã©craser cet index au prochain essai
c) LibÃ©rer lâ€™emplacement mÃ©moire
d) Appeler une fonction spÃ©ciale de nettoyage

QCM 4
Que se passe-t-il si tu affiches tous les Ã©lÃ©ments de subset[] jusquâ€™Ã  sa taille maximale sans prendre en compte la longueur courante (len)â€¯?

a) Tu obtiens toujours les sous-ensembles corrects
b) Tu risques dâ€™afficher des 0 ou des valeurs parasites
c) Tu peux avoir des rÃ©pÃ©titions dâ€™Ã©lÃ©ments
d) Ton programme peut crasher

QCM 5
Dans le code suivant, que fait exactement la variable posâ€¯?

c
Copier
Modifier
for (int pos = start; pos < nb_set; pos++) {
    subset[len] = set[pos];
    powerset(set, nb_set, pos + 1, subset, len + 1, sum + set[pos], target);
}
a) Elle sert Ã  parcourir tous les choix possibles Ã  partir dâ€™une position donnÃ©e
b) Elle indique la profondeur de la rÃ©cursion
c) Elle sert Ã  contrÃ´ler la taille de lâ€™ensemble initial
d) Elle nâ€™est pas utile

QCM 6
Quand faut-il arrÃªter la branche rÃ©cursive (en-dehors du cas de base)â€¯?

a) Quand la somme courante dÃ©passe la cible
b) Quand on atteint la fin du tableau
c) Quand subset[] est plein
d) Jamais, il faut explorer toutes les possibilitÃ©s
